{"version":3,"sources":["webpack:///./public/app/plugins/datasource/prometheus/metric_find_query.ts","webpack:///./public/app/plugins/datasource/prometheus/result_transformer.ts","webpack:///./public/app/plugins/datasource/prometheus/language_provider.ts","webpack:///./public/app/plugins/datasource/prometheus/query_hints.ts","webpack:///./public/app/plugins/datasource/prometheus/datasource.ts","webpack:///./public/app/plugins/datasource/prometheus/components/PromQueryField.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromLink.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromQueryEditor.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromCheatSheet.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromExploreExtraField.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromExploreQueryEditor.tsx","webpack:///./public/app/plugins/datasource/prometheus/configuration/PromSettings.tsx","webpack:///./public/app/plugins/datasource/prometheus/module.ts","webpack:///./public/app/plugins/datasource/prometheus/configuration/ConfigEditor.tsx","webpack:///./public/app/core/utils/CancelablePromise.ts"],"names":["PrometheusMetricFindQuery","datasource","query","this","range","getTimeSrv","timeRange","match","labelNamesQuery","labelValuesQuery","metricNamesQuery","metricNameQuery","queryResultQuery","toPromise","metricNameAndLabelsQuery","metadataRequest","then","result","_","map","data","value","text","label","metric","url","start","getPrometheusTime","from","end","to","params","URLSearchParams","toString","_labels","filter","uniq","expandable","metricFilterPattern","chain","metricName","RegExp","test","matchedMetricName","instantQuery","expr","performInstantQuery","pipe","metricData","__name__","v","k","join","self","getOriginalMetricName","ResultTransformer","templateSrv","response","options","prometheusResult","format","transformMetricDataToTable","responseListLength","refId","meta","valueWithRefId","seriesList","push","transformMetricData","sort","sortSeriesByLabel","transformToHistogramOverTime","resultType","transformInstantMetricData","dps","createLabelInfo","name","labels","title","stepMs","parseFloat","step","baseTimestamp","undefined","values","Error","dpValue","isNaN","timestamp","t","endTimestamp","datapoints","target","tags","md","resultCount","i","j","table","TableModel","metricLabels","length","each","series","hasOwnProperty","sortedLabels","keys","columns","type","FieldType","time","labelIndex","filterable","valueText","reordered","parseHistogramLabel","rows","legendFormat","renderTemplate","replace","scopedVars","labelsWithoutName","labelPart","formatLabels","labelData","Object","entries","aliasPattern","aliasData","g1","topSeries","bottomSeries","bottomPoint","s1","s2","le1","le2","err","console","error","le","Infinity","Number","DEFAULT_KEYS","wrapLabel","setFunctionKind","suggestion","kind","PREFIX_DELIMITER_REGEX","PromQlLanguageProvider","initialValues","labelsCache","LRU","request","defaultValue","res","lookupsDisabled","metrics","lookupMetricsThreshold","fixSummariesMetadata","metricsMetadata","processHistogramMetrics","processHistogramLabels","histogramMetrics","slice","provideCompletionItems","prefix","labelKey","wrapperClasses","context","history","emptyResult","suggestions","empty","document","selectedLines","getTextsAtRange","selection","currentLine","size","first","getText","nextCharacter","anchor","offset","tokenRecognized","prefixUnrecognized","noSuffix","safePrefix","operatorsPattern","isNextOperand","includes","getRangeCompletionItems","getLabelCompletionItems","getAggregationCompletionItems","getEmptyCompletionItems","getBeginningCompletionItems","getTermCompletionItems","historyItems","h","take","item","cutoffTs","Date","now","historyForItem","ts","count","recent","hint","lastQueried","dateTime","fromNow","documentation","addHistoryMetadata","prefixMatch","skipSort","items","FUNCTIONS","m","metadata","help","toUpperCase","addMetricsMetadata","queryText","getBlocks","reduce","block","blockText","anchorBlock","key","queryOffset","openParensAggregationIndex","lastIndexOf","openParensSelectorIndex","closeParensSelectorIndex","indexOf","closeParensAggregationIndex","selectorString","selector","parseSelector","getLabelValues","labelValues","line","cursorOffset","suffix","substr","isValueStart","isValueEnd","isPreValue","hasValuePrefix","parsedSelector","containsMetric","existingKeys","labelKeys","warn","possibleKeys","difference","newItems","newSuggestion","fetchLabelValues","fetchSeriesLabels","withName","tRange","getTimeRange","set","roundToMinutes","append","cacheKey","get","processLabels","fetchDefaultLabels","once","Promise","all","acc","assign","s","split","pop","trimLeft","RATE_RANGES","seconds","Math","floor","PromqlSyntax","LanguageProvider","getQueryHints","hints","trim","fix","action","nameMatch","counterNameMetric","languageProvider","metricMetadataKeys","certain","find","toLowerCase","metricRegex","simpleMetric","verb","ruleMappings","mapping","mappingForQuery","ruleName","search","preventSubmit","PrometheusDatasource","instanceSettings","init","loadRules","processResult","transformerOptions","preferredVisualisationType","instant","resultTransformer","transform","prepareTargets","queries","activeTargets","targets","hide","requestId","panelId","app","CoreApp","Explore","showingTable","instantTarget","cloneDeep","maxDataPoints","createQuery","showingGraph","handleErrors","message","statusText","safeStringifyValue","status","createAnnotationQueryOptions","annotation","interval","editorSrc","basicAuth","withCredentials","jsonData","timeInterval","queryTimeout","httpMethod","directUrl","PrometheusLanguageProvider","disableMetricsLookup","customQueryParameters","httpOptions","headers","dashboardId","overrides","defaults","method","encodeURIComponent","Authorization","getBackendSrv","fetch","_request","hideFromInspector","variable","multi","includeAll","prometheusRegularEscape","prometheusSpecialRegexEscape","escapedValues","val","variableExists","exploreQuery","panelsQuery","of","state","LoadingState","Done","runningQueriesCount","subQueries","index","performTimeSeriesQuery","tap","cancelled","Loading","merge","observables","forkJoin","results","current","hinting","ceil","rangeUtil","intervalToSeconds","minInterval","scrapeInterval","intervalFactor","adjustedInterval","adjustInterval","getRangeScopedVars","getRateIntervalScopedVariable","__interval","__interval_ms","getAdhocFilters","operator","addLabelToQuery","interpolateQueryExpr","adjusted","utcOffsetSec","alignedEnd","alignedStart","alignRange","utcOffset","_addTracingHeaders","rateInterval","max","__rate_interval","safeInterval","catchError","throwError","metricsNameCache","expire","resolve","intervalToMs","interpolated","metricFindQuery","process","msRange","diff","sRange","round","__range_ms","__range_s","__range","tagKeys","titleFormat","textFormat","queryOptions","queryModel","eventList","splitKeys","forEach","timestampValue","useValueForTime","activeValuesTimestamps","latestEvent","timeEnd","getTime","expandedQueries","groups","extractRuleMappingFromGroups","log","expression","expandRecordingRules","date","roundUp","dateMath","parse","valueOf","DataSourceApi","group","rules","rule","HISTOGRAM_GROUP","willApplySuggestion","typeaheadContext","typeaheadText","nextChar","DOMUtil","getNextCharacter","PromQueryField","props","refreshHint","isDataFrame","toLegacyResponseData","setState","refreshMetrics","syntaxLoaded","Prism","languages","syntax","languageProviderInitializationPromise","makePromiseCancelable","promise","remaining","task","onUpdateLanguage","catch","isCanceled","onChangeMetrics","selectedOptions","selectedOption","children","onChangeQuery","override","onChange","onRunQuery","onClickHintFix","modifyQuery","metricsByPrefix","ruleRegex","ruleNames","rulesOption","metricsOptions","groupBy","metricsForPrefix","option","sortBy","groupMetricsByPrefix","histogramOptions","hm","isLeaf","onTypeahead","typeahead","plugins","BracesPlugin","SlatePrism","onlyIn","node","getSyntax","cancel","prevProps","metricsLookupDisabled","hasSyntax","ExtraFieldElement","cleanText","chooserText","buttonDisabled","className","disabled","additionalPlugins","onWillApplySuggestion","onBlur","placeholder","portalOrigin","onClick","React","PureComponent","PromLink","href","panelData","getExternalLink","rangeDiff","endTime","utc","args","rel","Component","Switch","LegacyForms","FORMAT_OPTIONS","INTERVAL_FACTOR_OPTIONS","PromQueryEditor","onFieldChange","onFormatChange","formatOption","onInstantChange","e","checked","onIntervalChange","currentTarget","onIntervalFactorChange","intervalFactorOption","onLegendChange","Boolean","width","tooltip","isSearchable","menuPlacement","CHEAT_SHEET_ITEMS","PromExploreExtraField","onChangeFunc","onKeyDownFunc","hasTooltip","tooltipContent","aria-label","onKeyDown","memo","onChangeQueryStep","Select","Input","FormField","PromSettings","onOptionsChange","labelWidth","inputEl","spellCheck","onChangeHandler","validationEvents","promSettingsValidationEvents","o","labelClass","onUpdateDatasourceJsonDataOptionChecked","EventsWithValidation","regexValidation","getValueFromEventItem","eventItem","PrometheusAnnotationsQueryCtrl","stepDefaultValuePlaceholder","templateUrl","plugin","DataSourcePlugin","setQueryEditor","setConfigEditor","defaultUrl","dataSourceConfig","showAccessOptions","setExploreMetricsQueryField","PromExploreQueryEditor","setAnnotationQueryCtrl","setExploreStartPage","onClickExample","hasCanceled_","reject"],"mappings":"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","file":"prometheusPlugin.4e20f99bf66682942589.js","sourcesContent":["import _ from 'lodash';\nimport { map } from 'rxjs/operators';\nimport { MetricFindValue, TimeRange } from '@grafana/data';\nimport { PromDataQueryResponse, PrometheusDatasource } from './datasource';\nimport { PromQueryRequest } from './types';\nimport { getTimeSrv } from 'app/features/dashboard/services/TimeSrv';\n\nexport default class PrometheusMetricFindQuery {\n  range: TimeRange;\n\n  constructor(private datasource: PrometheusDatasource, private query: string) {\n    this.datasource = datasource;\n    this.query = query;\n    this.range = getTimeSrv().timeRange();\n  }\n\n  process(): Promise<MetricFindValue[]> {\n    const labelNamesRegex = /^label_names\\(\\)\\s*$/;\n    const labelValuesRegex = /^label_values\\((?:(.+),\\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\\)\\s*$/;\n    const metricNamesRegex = /^metrics\\((.+)\\)\\s*$/;\n    const queryResultRegex = /^query_result\\((.+)\\)\\s*$/;\n    const labelNamesQuery = this.query.match(labelNamesRegex);\n    if (labelNamesQuery) {\n      return this.labelNamesQuery();\n    }\n\n    const labelValuesQuery = this.query.match(labelValuesRegex);\n    if (labelValuesQuery) {\n      if (labelValuesQuery[1]) {\n        return this.labelValuesQuery(labelValuesQuery[2], labelValuesQuery[1]);\n      } else {\n        return this.labelValuesQuery(labelValuesQuery[2]);\n      }\n    }\n\n    const metricNamesQuery = this.query.match(metricNamesRegex);\n    if (metricNamesQuery) {\n      return this.metricNameQuery(metricNamesQuery[1]);\n    }\n\n    const queryResultQuery = this.query.match(queryResultRegex);\n    if (queryResultQuery) {\n      return this.queryResultQuery(queryResultQuery[1]).toPromise();\n    }\n\n    // if query contains full metric name, return metric name and label list\n    return this.metricNameAndLabelsQuery(this.query);\n  }\n\n  labelNamesQuery() {\n    const url = '/api/v1/labels';\n    return this.datasource.metadataRequest(url).then((result: any) => {\n      return _.map(result.data.data, value => {\n        return { text: value };\n      });\n    });\n  }\n\n  labelValuesQuery(label: string, metric?: string) {\n    let url: string;\n\n    if (!metric) {\n      // return label values globally\n      url = '/api/v1/label/' + label + '/values';\n\n      return this.datasource.metadataRequest(url).then((result: any) => {\n        return _.map(result.data.data, value => {\n          return { text: value };\n        });\n      });\n    } else {\n      const start = this.datasource.getPrometheusTime(this.range.from, false);\n      const end = this.datasource.getPrometheusTime(this.range.to, true);\n      const params = new URLSearchParams({\n        'match[]': metric,\n        start: start.toString(),\n        end: end.toString(),\n      });\n      url = `/api/v1/series?${params.toString()}`;\n\n      return this.datasource.metadataRequest(url).then((result: any) => {\n        const _labels = _.map(result.data.data, metric => {\n          return metric[label] || '';\n        }).filter(label => {\n          return label !== '';\n        });\n\n        return _.uniq(_labels).map(metric => {\n          return {\n            text: metric,\n            expandable: true,\n          };\n        });\n      });\n    }\n  }\n\n  metricNameQuery(metricFilterPattern: string) {\n    const url = '/api/v1/label/__name__/values';\n\n    return this.datasource.metadataRequest(url).then((result: any) => {\n      return _.chain(result.data.data)\n        .filter(metricName => {\n          const r = new RegExp(metricFilterPattern);\n          return r.test(metricName);\n        })\n        .map(matchedMetricName => {\n          return {\n            text: matchedMetricName,\n            expandable: true,\n          };\n        })\n        .value();\n    });\n  }\n\n  queryResultQuery(query: string) {\n    const end = this.datasource.getPrometheusTime(this.range.to, true);\n    const instantQuery: PromQueryRequest = { expr: query } as PromQueryRequest;\n    return this.datasource.performInstantQuery(instantQuery, end).pipe(\n      map((result: PromDataQueryResponse) => {\n        return _.map(result.data.data.result, metricData => {\n          let text = metricData.metric.__name__ || '';\n          delete metricData.metric.__name__;\n          text +=\n            '{' +\n            _.map(metricData.metric, (v, k) => {\n              return k + '=\"' + v + '\"';\n            }).join(',') +\n            '}';\n          text += ' ' + metricData.value[1] + ' ' + metricData.value[0] * 1000;\n\n          return {\n            text: text,\n            expandable: true,\n          };\n        });\n      })\n    );\n  }\n\n  metricNameAndLabelsQuery(query: string): Promise<MetricFindValue[]> {\n    const start = this.datasource.getPrometheusTime(this.range.from, false);\n    const end = this.datasource.getPrometheusTime(this.range.to, true);\n    const params = new URLSearchParams({\n      'match[]': query,\n      start: start.toString(),\n      end: end.toString(),\n    });\n\n    const url = `/api/v1/series?${params.toString()}`;\n    const self = this;\n\n    return this.datasource.metadataRequest(url).then((result: any) => {\n      return _.map(result.data.data, (metric: { [key: string]: string }) => {\n        return {\n          text: self.datasource.getOriginalMetricName(metric),\n          expandable: true,\n        };\n      });\n    });\n  }\n}\n","import _ from 'lodash';\nimport TableModel from 'app/core/table_model';\nimport { TimeSeries, FieldType, Labels, formatLabels, QueryResultMeta } from '@grafana/data';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\n\nexport class ResultTransformer {\n  constructor(private templateSrv: TemplateSrv) {}\n\n  transform(response: any, options: any): Array<TableModel | TimeSeries> {\n    const prometheusResult = response.data.data.result;\n\n    if (options.format === 'table') {\n      return [\n        this.transformMetricDataToTable(\n          prometheusResult,\n          options.responseListLength,\n          options.refId,\n          options.meta,\n          options.valueWithRefId\n        ),\n      ];\n    } else if (prometheusResult && options.format === 'heatmap') {\n      let seriesList: TimeSeries[] = [];\n      for (const metricData of prometheusResult) {\n        seriesList.push(this.transformMetricData(metricData, options, options.start, options.end));\n      }\n      seriesList.sort(sortSeriesByLabel);\n      seriesList = this.transformToHistogramOverTime(seriesList);\n      return seriesList;\n    } else if (prometheusResult) {\n      const seriesList: TimeSeries[] = [];\n      for (const metricData of prometheusResult) {\n        if (response.data.data.resultType === 'matrix') {\n          seriesList.push(this.transformMetricData(metricData, options, options.start, options.end));\n        } else if (response.data.data.resultType === 'vector') {\n          seriesList.push(this.transformInstantMetricData(metricData, options));\n        }\n      }\n      return seriesList;\n    }\n    return [];\n  }\n\n  transformMetricData(metricData: any, options: any, start: number, end: number): TimeSeries {\n    const dps = [];\n    const { name, labels, title } = this.createLabelInfo(metricData.metric, options);\n\n    const stepMs = parseFloat(options.step) * 1000;\n    let baseTimestamp = start * 1000;\n\n    if (metricData.values === undefined) {\n      throw new Error('Prometheus heatmap error: data should be a time series');\n    }\n\n    for (const value of metricData.values) {\n      let dpValue: number | null = parseFloat(value[1]);\n\n      if (_.isNaN(dpValue)) {\n        dpValue = null;\n      }\n\n      const timestamp = parseFloat(value[0]) * 1000;\n      for (let t = baseTimestamp; t < timestamp; t += stepMs) {\n        dps.push([null, t]);\n      }\n      baseTimestamp = timestamp + stepMs;\n      dps.push([dpValue, timestamp]);\n    }\n\n    const endTimestamp = end * 1000;\n    for (let t = baseTimestamp; t <= endTimestamp; t += stepMs) {\n      dps.push([null, t]);\n    }\n\n    return {\n      datapoints: dps,\n      refId: options.refId,\n      target: name ?? '',\n      tags: labels,\n      title,\n      meta: options.meta,\n    };\n  }\n\n  transformMetricDataToTable(\n    md: any,\n    resultCount: number,\n    refId: string,\n    meta: QueryResultMeta,\n    valueWithRefId?: boolean\n  ): TableModel {\n    const table = new TableModel();\n    table.refId = refId;\n    table.meta = meta;\n\n    let i: number, j: number;\n    const metricLabels: { [key: string]: number } = {};\n\n    if (!md || md.length === 0) {\n      return table;\n    }\n\n    // Collect all labels across all metrics\n    _.each(md, series => {\n      for (const label in series.metric) {\n        if (!metricLabels.hasOwnProperty(label)) {\n          metricLabels[label] = 1;\n        }\n      }\n    });\n\n    // Sort metric labels, create columns for them and record their index\n    const sortedLabels = _.keys(metricLabels).sort();\n    table.columns.push({ text: 'Time', type: FieldType.time });\n    _.each(sortedLabels, (label, labelIndex) => {\n      metricLabels[label] = labelIndex + 1;\n      table.columns.push({ text: label, filterable: true });\n    });\n    const valueText = resultCount > 1 || valueWithRefId ? `Value #${refId}` : 'Value';\n    table.columns.push({ text: valueText });\n\n    // Populate rows, set value to empty string when label not present.\n    _.each(md, series => {\n      if (series.value) {\n        series.values = [series.value];\n      }\n      if (series.values) {\n        for (i = 0; i < series.values.length; i++) {\n          const values = series.values[i];\n          const reordered: any = [values[0] * 1000];\n          if (series.metric) {\n            for (j = 0; j < sortedLabels.length; j++) {\n              const label = sortedLabels[j];\n              if (series.metric.hasOwnProperty(label)) {\n                if (label === 'le') {\n                  reordered.push(parseHistogramLabel(series.metric[label]));\n                } else {\n                  reordered.push(series.metric[label]);\n                }\n              } else {\n                reordered.push('');\n              }\n            }\n          }\n          reordered.push(parseFloat(values[1]));\n          table.rows.push(reordered);\n        }\n      }\n    });\n\n    return table;\n  }\n\n  transformInstantMetricData(md: any, options: any): TimeSeries {\n    const dps = [];\n    const { name, labels } = this.createLabelInfo(md.metric, options);\n    dps.push([parseFloat(md.value[1]), md.value[0] * 1000]);\n    return { target: name ?? '', title: name, datapoints: dps, tags: labels, refId: options.refId, meta: options.meta };\n  }\n\n  createLabelInfo(labels: { [key: string]: string }, options: any): { name?: string; labels: Labels; title?: string } {\n    if (options?.legendFormat) {\n      const title = this.renderTemplate(this.templateSrv.replace(options.legendFormat, options?.scopedVars), labels);\n      return { name: title, title, labels };\n    }\n\n    let { __name__, ...labelsWithoutName } = labels;\n\n    let title = __name__ || '';\n\n    const labelPart = formatLabels(labelsWithoutName);\n\n    if (!title && !labelPart) {\n      title = options.query;\n    }\n\n    title = `${__name__ ?? ''}${labelPart}`;\n\n    return { name: title, title, labels: labelsWithoutName };\n  }\n\n  getOriginalMetricName(labelData: { [key: string]: string }) {\n    const metricName = labelData.__name__ || '';\n    delete labelData.__name__;\n    const labelPart = Object.entries(labelData)\n      .map(label => `${label[0]}=\"${label[1]}\"`)\n      .join(',');\n    return `${metricName}{${labelPart}}`;\n  }\n\n  renderTemplate(aliasPattern: string, aliasData: { [key: string]: string }) {\n    const aliasRegex = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\n    return aliasPattern.replace(aliasRegex, (match, g1) => {\n      if (aliasData[g1]) {\n        return aliasData[g1];\n      }\n      return '';\n    });\n  }\n\n  transformToHistogramOverTime(seriesList: TimeSeries[]) {\n    /*      t1 = timestamp1, t2 = timestamp2 etc.\n            t1  t2  t3          t1  t2  t3\n    le10    10  10  0     =>    10  10  0\n    le20    20  10  30    =>    10  0   30\n    le30    30  10  35    =>    10  0   5\n    */\n    for (let i = seriesList.length - 1; i > 0; i--) {\n      const topSeries = seriesList[i].datapoints;\n      const bottomSeries = seriesList[i - 1].datapoints;\n      if (!topSeries || !bottomSeries) {\n        throw new Error('Prometheus heatmap transform error: data should be a time series');\n      }\n\n      for (let j = 0; j < topSeries.length; j++) {\n        const bottomPoint = bottomSeries[j] || [0];\n        topSeries[j][0]! -= bottomPoint[0]!;\n      }\n    }\n\n    return seriesList;\n  }\n}\n\nfunction sortSeriesByLabel(s1: TimeSeries, s2: TimeSeries): number {\n  let le1, le2;\n\n  try {\n    // fail if not integer. might happen with bad queries\n    le1 = parseHistogramLabel(s1.target);\n    le2 = parseHistogramLabel(s2.target);\n  } catch (err) {\n    console.error(err);\n    return 0;\n  }\n\n  if (le1 > le2) {\n    return 1;\n  }\n\n  if (le1 < le2) {\n    return -1;\n  }\n\n  return 0;\n}\n\nfunction parseHistogramLabel(le: string): number {\n  if (le === '+Inf') {\n    return +Infinity;\n  }\n  return Number(le);\n}\n","import _ from 'lodash';\nimport LRU from 'lru-cache';\nimport { Value } from 'slate';\n\nimport { dateTime, HistoryItem, LanguageProvider } from '@grafana/data';\nimport { CompletionItem, CompletionItemGroup, TypeaheadInput, TypeaheadOutput } from '@grafana/ui';\n\nimport { fixSummariesMetadata, parseSelector, processHistogramLabels, processLabels } from './language_utils';\nimport PromqlSyntax, { FUNCTIONS, RATE_RANGES } from './promql';\n\nimport { PrometheusDatasource } from './datasource';\nimport { PromMetricsMetadata, PromQuery } from './types';\n\nconst DEFAULT_KEYS = ['job', 'instance'];\nconst EMPTY_SELECTOR = '{}';\nconst HISTORY_ITEM_COUNT = 5;\nconst HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h\nexport const DEFAULT_LOOKUP_METRICS_THRESHOLD = 10000; // number of metrics defining an installation that's too big\n\nconst wrapLabel = (label: string): CompletionItem => ({ label });\n\nconst setFunctionKind = (suggestion: CompletionItem): CompletionItem => {\n  suggestion.kind = 'function';\n  return suggestion;\n};\n\nexport function addHistoryMetadata(item: CompletionItem, history: any[]): CompletionItem {\n  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;\n  const historyForItem = history.filter(h => h.ts > cutoffTs && h.query === item.label);\n  const count = historyForItem.length;\n  const recent = historyForItem[0];\n  let hint = `Queried ${count} times in the last 24h.`;\n\n  if (recent) {\n    const lastQueried = dateTime(recent.ts).fromNow();\n    hint = `${hint} Last queried ${lastQueried}.`;\n  }\n\n  return {\n    ...item,\n    documentation: hint,\n  };\n}\n\nfunction addMetricsMetadata(metric: string, metadata?: PromMetricsMetadata): CompletionItem {\n  const item: CompletionItem = { label: metric };\n  if (metadata && metadata[metric]) {\n    const { type, help } = metadata[metric][0];\n    item.documentation = `${type.toUpperCase()}: ${help}`;\n  }\n  return item;\n}\n\nconst PREFIX_DELIMITER_REGEX = /(=\"|!=\"|=~\"|!~\"|\\{|\\[|\\(|\\+|-|\\/|\\*|%|\\^|\\band\\b|\\bor\\b|\\bunless\\b|==|>=|!=|<=|>|<|=|~|,)/;\n\nexport default class PromQlLanguageProvider extends LanguageProvider {\n  histogramMetrics: string[];\n  timeRange?: { start: number; end: number };\n  metrics: string[];\n  metricsMetadata?: PromMetricsMetadata;\n  startTask: Promise<any>;\n  datasource: PrometheusDatasource;\n  lookupMetricsThreshold: number;\n  lookupsDisabled: boolean; // Dynamically set to true for big/slow instances\n\n  /**\n   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does\n   *  not account for different size of a response. If that is needed a `length` function can be added in the options.\n   *  10 as a max size is totally arbitrary right now.\n   */\n  private labelsCache = new LRU<string, Record<string, string[]>>(10);\n\n  constructor(datasource: PrometheusDatasource, initialValues?: Partial<PromQlLanguageProvider>) {\n    super();\n\n    this.datasource = datasource;\n    this.histogramMetrics = [];\n    this.timeRange = { start: 0, end: 0 };\n    this.metrics = [];\n    // Disable lookups until we know the instance is small enough\n    this.lookupMetricsThreshold = DEFAULT_LOOKUP_METRICS_THRESHOLD;\n    this.lookupsDisabled = true;\n\n    Object.assign(this, initialValues);\n  }\n\n  // Strip syntax chars so that typeahead suggestions can work on clean inputs\n  cleanText(s: string) {\n    const parts = s.split(PREFIX_DELIMITER_REGEX);\n    const last = parts.pop()!;\n    return last\n      .trimLeft()\n      .replace(/\"$/, '')\n      .replace(/^\"/, '');\n  }\n\n  get syntax() {\n    return PromqlSyntax;\n  }\n\n  request = async (url: string, defaultValue: any): Promise<any> => {\n    try {\n      const res = await this.datasource.metadataRequest(url);\n      return res.data.data;\n    } catch (error) {\n      console.error(error);\n    }\n\n    return defaultValue;\n  };\n\n  start = async (): Promise<any[]> => {\n    if (this.datasource.lookupsDisabled) {\n      return [];\n    }\n\n    this.metrics = await this.request('/api/v1/label/__name__/values', []);\n    this.lookupsDisabled = this.metrics.length > this.lookupMetricsThreshold;\n    this.metricsMetadata = fixSummariesMetadata(await this.request('/api/v1/metadata', {}));\n    this.processHistogramMetrics(this.metrics);\n\n    return [];\n  };\n\n  processHistogramMetrics = (data: string[]) => {\n    const { values } = processHistogramLabels(data);\n\n    if (values && values['__name__']) {\n      this.histogramMetrics = values['__name__'].slice().sort();\n    }\n  };\n\n  provideCompletionItems = async (\n    { prefix, text, value, labelKey, wrapperClasses }: TypeaheadInput,\n    context: { history: Array<HistoryItem<PromQuery>> } = { history: [] }\n  ): Promise<TypeaheadOutput> => {\n    const emptyResult: TypeaheadOutput = { suggestions: [] };\n\n    if (!value) {\n      return emptyResult;\n    }\n\n    // Local text properties\n    const empty = value.document.text.length === 0;\n    const selectedLines = value.document.getTextsAtRange(value.selection);\n    const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;\n\n    const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null;\n\n    // Syntax spans have 3 classes by default. More indicate a recognized token\n    const tokenRecognized = wrapperClasses.length > 3;\n    // Non-empty prefix, but not inside known token\n    const prefixUnrecognized = prefix && !tokenRecognized;\n\n    // Prevent suggestions in `function(|suffix)`\n    const noSuffix = !nextCharacter || nextCharacter === ')';\n\n    // Prefix is safe if it does not immediately follow a complete expression and has no text after it\n    const safePrefix = prefix && !text.match(/^[\\]})\\s]+$/) && noSuffix;\n\n    // About to type next operand if preceded by binary operator\n    const operatorsPattern = /[+\\-*/^%]/;\n    const isNextOperand = text.match(operatorsPattern);\n\n    // Determine candidates by CSS context\n    if (wrapperClasses.includes('context-range')) {\n      // Suggestions for metric[|]\n      return this.getRangeCompletionItems();\n    } else if (wrapperClasses.includes('context-labels')) {\n      // Suggestions for metric{|} and metric{foo=|}, as well as metric-independent label queries like {|}\n      return this.getLabelCompletionItems({ prefix, text, value, labelKey, wrapperClasses });\n    } else if (wrapperClasses.includes('context-aggregation')) {\n      // Suggestions for sum(metric) by (|)\n      return this.getAggregationCompletionItems(value);\n    } else if (empty) {\n      // Suggestions for empty query field\n      return this.getEmptyCompletionItems(context);\n    } else if (prefixUnrecognized && noSuffix && !isNextOperand) {\n      // Show term suggestions in a couple of scenarios\n      return this.getBeginningCompletionItems(context);\n    } else if (prefixUnrecognized && safePrefix) {\n      // Show term suggestions in a couple of scenarios\n      return this.getTermCompletionItems();\n    }\n\n    return emptyResult;\n  };\n\n  getBeginningCompletionItems = (context: { history: Array<HistoryItem<PromQuery>> }): TypeaheadOutput => {\n    return {\n      suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions],\n    };\n  };\n\n  getEmptyCompletionItems = (context: { history: Array<HistoryItem<PromQuery>> }): TypeaheadOutput => {\n    const { history } = context;\n    const suggestions = [];\n\n    if (history && history.length) {\n      const historyItems = _.chain(history)\n        .map(h => h.query.expr)\n        .filter()\n        .uniq()\n        .take(HISTORY_ITEM_COUNT)\n        .map(wrapLabel)\n        .map(item => addHistoryMetadata(item, history))\n        .value();\n\n      suggestions.push({\n        prefixMatch: true,\n        skipSort: true,\n        label: 'History',\n        items: historyItems,\n      });\n    }\n\n    return { suggestions };\n  };\n\n  getTermCompletionItems = (): TypeaheadOutput => {\n    const { metrics, metricsMetadata } = this;\n    const suggestions = [];\n\n    suggestions.push({\n      prefixMatch: true,\n      label: 'Functions',\n      items: FUNCTIONS.map(setFunctionKind),\n    });\n\n    if (metrics && metrics.length) {\n      suggestions.push({\n        label: 'Metrics',\n        items: metrics.map(m => addMetricsMetadata(m, metricsMetadata)),\n      });\n    }\n\n    return { suggestions };\n  };\n\n  getRangeCompletionItems(): TypeaheadOutput {\n    return {\n      context: 'context-range',\n      suggestions: [\n        {\n          label: 'Range vector',\n          items: [...RATE_RANGES],\n        },\n      ],\n    };\n  }\n\n  getAggregationCompletionItems = async (value: Value): Promise<TypeaheadOutput> => {\n    const suggestions: CompletionItemGroup[] = [];\n\n    // Stitch all query lines together to support multi-line queries\n    let queryOffset;\n    const queryText = value.document.getBlocks().reduce((text: string, block) => {\n      if (!block) {\n        return text;\n      }\n\n      const blockText = block?.getText();\n\n      if (value.anchorBlock.key === block.key) {\n        // Newline characters are not accounted for but this is irrelevant\n        // for the purpose of extracting the selector string\n        queryOffset = value.selection.anchor.offset + text.length;\n      }\n\n      return text + blockText;\n    }, '');\n\n    // Try search for selector part on the left-hand side, such as `sum (m) by (l)`\n    const openParensAggregationIndex = queryText.lastIndexOf('(', queryOffset);\n    let openParensSelectorIndex = queryText.lastIndexOf('(', openParensAggregationIndex - 1);\n    let closeParensSelectorIndex = queryText.indexOf(')', openParensSelectorIndex);\n\n    // Try search for selector part of an alternate aggregation clause, such as `sum by (l) (m)`\n    if (openParensSelectorIndex === -1) {\n      const closeParensAggregationIndex = queryText.indexOf(')', queryOffset);\n      closeParensSelectorIndex = queryText.indexOf(')', closeParensAggregationIndex + 1);\n      openParensSelectorIndex = queryText.lastIndexOf('(', closeParensSelectorIndex);\n    }\n\n    const result = {\n      suggestions,\n      context: 'context-aggregation',\n    };\n\n    // Suggestions are useless for alternative aggregation clauses without a selector in context\n    if (openParensSelectorIndex === -1) {\n      return result;\n    }\n\n    // Range vector syntax not accounted for by subsequent parse so discard it if present\n    const selectorString = queryText\n      .slice(openParensSelectorIndex + 1, closeParensSelectorIndex)\n      .replace(/\\[[^\\]]+\\]$/, '');\n\n    const selector = parseSelector(selectorString, selectorString.length - 2).selector;\n\n    const labelValues = await this.getLabelValues(selector);\n    if (labelValues) {\n      suggestions.push({ label: 'Labels', items: Object.keys(labelValues).map(wrapLabel) });\n    }\n    return result;\n  };\n\n  getLabelCompletionItems = async ({\n    text,\n    wrapperClasses,\n    labelKey,\n    value,\n  }: TypeaheadInput): Promise<TypeaheadOutput> => {\n    if (!value) {\n      return { suggestions: [] };\n    }\n\n    const suggestions: CompletionItemGroup[] = [];\n    const line = value.anchorBlock.getText();\n    const cursorOffset = value.selection.anchor.offset;\n    const suffix = line.substr(cursorOffset);\n    const prefix = line.substr(0, cursorOffset);\n    const isValueStart = text.match(/^(=|=~|!=|!~)/);\n    const isValueEnd = suffix.match(/^\"?[,}]/);\n    // detect cursor in front of value, e.g., {key=|\"}\n    const isPreValue = prefix.match(/(=|=~|!=|!~)$/) && suffix.match(/^\"/);\n\n    // Don't suggestq anything at the beginning or inside a value\n    const isValueEmpty = isValueStart && isValueEnd;\n    const hasValuePrefix = isValueEnd && !isValueStart;\n    if ((!isValueEmpty && !hasValuePrefix) || isPreValue) {\n      return { suggestions };\n    }\n\n    // Get normalized selector\n    let selector;\n    let parsedSelector;\n    try {\n      parsedSelector = parseSelector(line, cursorOffset);\n      selector = parsedSelector.selector;\n    } catch {\n      selector = EMPTY_SELECTOR;\n    }\n\n    const containsMetric = selector.includes('__name__=');\n    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];\n\n    let labelValues;\n    // Query labels for selector\n    if (selector) {\n      labelValues = await this.getLabelValues(selector, !containsMetric);\n    }\n\n    if (!labelValues) {\n      console.warn(`Server did not return any values for selector = ${selector}`);\n      return { suggestions };\n    }\n\n    let context: string | undefined;\n\n    if ((text && isValueStart) || wrapperClasses.includes('attr-value')) {\n      // Label values\n      if (labelKey && labelValues[labelKey]) {\n        context = 'context-label-values';\n        suggestions.push({\n          label: `Label values for \"${labelKey}\"`,\n          items: labelValues[labelKey].map(wrapLabel),\n        });\n      }\n    } else {\n      // Label keys\n      const labelKeys = labelValues ? Object.keys(labelValues) : containsMetric ? null : DEFAULT_KEYS;\n\n      if (labelKeys) {\n        const possibleKeys = _.difference(labelKeys, existingKeys);\n        if (possibleKeys.length) {\n          context = 'context-labels';\n          const newItems = possibleKeys.map(key => ({ label: key }));\n          const newSuggestion: CompletionItemGroup = { label: `Labels`, items: newItems };\n          suggestions.push(newSuggestion);\n        }\n      }\n    }\n\n    return { context, suggestions };\n  };\n\n  async getLabelValues(selector: string, withName?: boolean) {\n    if (this.lookupsDisabled) {\n      return undefined;\n    }\n    try {\n      if (selector === EMPTY_SELECTOR) {\n        return await this.fetchDefaultLabels();\n      } else {\n        return await this.fetchSeriesLabels(selector, withName);\n      }\n    } catch (error) {\n      // TODO: better error handling\n      console.error(error);\n      return undefined;\n    }\n  }\n\n  fetchLabelValues = async (key: string): Promise<Record<string, string[]>> => {\n    const data = await this.request(`/api/v1/label/${key}/values`, []);\n    return { [key]: data };\n  };\n\n  roundToMinutes(seconds: number): number {\n    return Math.floor(seconds / 60);\n  }\n\n  /**\n   * Fetch labels for a series. This is cached by it's args but also by the global timeRange currently selected as\n   * they can change over requested time.\n   * @param name\n   * @param withName\n   */\n  fetchSeriesLabels = async (name: string, withName?: boolean): Promise<Record<string, string[]>> => {\n    const tRange = this.datasource.getTimeRange();\n    const params = new URLSearchParams({\n      'match[]': name,\n      start: tRange['start'].toString(),\n      end: tRange['end'].toString(),\n    });\n    const url = `/api/v1/series?${params.toString()}`;\n    // Cache key is a bit different here. We add the `withName` param and also round up to a minute the intervals.\n    // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every\n    // millisecond while still actually getting all the keys for the correct interval. This still can create problems\n    // when user does not the newest values for a minute if already cached.\n    params.set('start', this.roundToMinutes(tRange['start']).toString());\n    params.set('end', this.roundToMinutes(tRange['end']).toString());\n    params.append('withName', withName ? 'true' : 'false');\n    const cacheKey = `/api/v1/series?${params.toString()}`;\n    let value = this.labelsCache.get(cacheKey);\n    if (!value) {\n      const data = await this.request(url, []);\n      const { values } = processLabels(data, withName);\n      value = values;\n      this.labelsCache.set(cacheKey, value);\n    }\n    return value;\n  };\n\n  /**\n   * Fetch this only one as we assume this won't change over time. This is cached differently from fetchSeriesLabels\n   * because we can cache more aggressively here and also we do not want to invalidate this cache the same way as in\n   * fetchSeriesLabels.\n   */\n  fetchDefaultLabels = _.once(async () => {\n    const values = await Promise.all(DEFAULT_KEYS.map(key => this.fetchLabelValues(key)));\n    return values.reduce((acc, value) => ({ ...acc, ...value }), {});\n  });\n}\n","import _ from 'lodash';\nimport { QueryHint, QueryFix } from '@grafana/data';\nimport { PrometheusDatasource } from './datasource';\n\n/**\n * Number of time series results needed before starting to suggest sum aggregation hints\n */\nexport const SUM_HINT_THRESHOLD_COUNT = 20;\n\nexport function getQueryHints(query: string, series?: any[], datasource?: PrometheusDatasource): QueryHint[] {\n  const hints = [];\n\n  // ..._bucket metric needs a histogram_quantile()\n  const histogramMetric = query.trim().match(/^\\w+_bucket$/);\n  if (histogramMetric) {\n    const label = 'Time series has buckets, you probably wanted a histogram.';\n    hints.push({\n      type: 'HISTOGRAM_QUANTILE',\n      label,\n      fix: {\n        label: 'Fix by adding histogram_quantile().',\n        action: {\n          type: 'ADD_HISTOGRAM_QUANTILE',\n          query,\n        },\n      } as QueryFix,\n    });\n  }\n\n  // Check for need of rate()\n  if (query.indexOf('rate(') === -1 && query.indexOf('increase(') === -1) {\n    // Use metric metadata for exact types\n    const nameMatch = query.match(/\\b(\\w+_(total|sum|count))\\b/);\n    let counterNameMetric = nameMatch ? nameMatch[1] : '';\n    const metricsMetadata = datasource?.languageProvider?.metricsMetadata ?? {};\n    const metricMetadataKeys = Object.keys(metricsMetadata);\n    let certain = false;\n\n    if (metricMetadataKeys.length > 0) {\n      counterNameMetric =\n        metricMetadataKeys.find(metricName => {\n          // Only considering first type information, could be non-deterministic\n          const metadata = metricsMetadata[metricName][0];\n          if (metadata.type.toLowerCase() === 'counter') {\n            const metricRegex = new RegExp(`\\\\b${metricName}\\\\b`);\n            if (query.match(metricRegex)) {\n              certain = true;\n              return true;\n            }\n          }\n          return false;\n        }) ?? '';\n    }\n\n    if (counterNameMetric) {\n      const simpleMetric = query.trim().match(/^\\w+$/);\n      const verb = certain ? 'is' : 'looks like';\n      let label = `Metric ${counterNameMetric} ${verb} a counter.`;\n      let fix: QueryFix | undefined;\n\n      if (simpleMetric) {\n        fix = {\n          label: 'Fix by adding rate().',\n          action: {\n            type: 'ADD_RATE',\n            query,\n          },\n        };\n      } else {\n        label = `${label} Try applying a rate() function.`;\n      }\n\n      hints.push({\n        type: 'APPLY_RATE',\n        label,\n        fix,\n      });\n    }\n  }\n\n  // Check for recording rules expansion\n  if (datasource && datasource.ruleMappings) {\n    const mapping = datasource.ruleMappings;\n    const mappingForQuery = Object.keys(mapping).reduce((acc, ruleName) => {\n      if (query.search(ruleName) > -1) {\n        return {\n          ...acc,\n          [ruleName]: mapping[ruleName],\n        };\n      }\n      return acc;\n    }, {});\n    if (_.size(mappingForQuery) > 0) {\n      const label = 'Query contains recording rules.';\n      hints.push({\n        type: 'EXPAND_RULES',\n        label,\n        fix: ({\n          label: 'Expand rules',\n          action: {\n            type: 'EXPAND_RULES',\n            query,\n            mapping: mappingForQuery,\n          },\n        } as any) as QueryFix,\n      });\n    }\n  }\n\n  if (series && series.length >= SUM_HINT_THRESHOLD_COUNT) {\n    const simpleMetric = query.trim().match(/^\\w+$/);\n    if (simpleMetric) {\n      hints.push({\n        type: 'ADD_SUM',\n        label: 'Many time series results returned.',\n        fix: {\n          label: 'Consider aggregating with sum().',\n          action: {\n            type: 'ADD_SUM',\n            query: query,\n            preventSubmit: true,\n          },\n        } as QueryFix,\n      });\n    }\n  }\n\n  return hints;\n}\n","// Libraries\nimport cloneDeep from 'lodash/cloneDeep';\n// Services & Utils\nimport {\n  AnnotationEvent,\n  CoreApp,\n  DataQueryError,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataQueryResponseData,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  dateMath,\n  DateTime,\n  LoadingState,\n  ScopedVars,\n  TimeRange,\n  TimeSeries,\n  rangeUtil,\n} from '@grafana/data';\nimport { forkJoin, merge, Observable, of, throwError } from 'rxjs';\nimport { catchError, filter, map, tap } from 'rxjs/operators';\n\nimport PrometheusMetricFindQuery from './metric_find_query';\nimport { ResultTransformer } from './result_transformer';\nimport PrometheusLanguageProvider from './language_provider';\nimport { BackendSrvRequest, getBackendSrv } from '@grafana/runtime';\nimport addLabelToQuery from './add_label_to_query';\nimport { getQueryHints } from './query_hints';\nimport { expandRecordingRules } from './language_utils';\n// Types\nimport { PromOptions, PromQuery, PromQueryRequest } from './types';\nimport { safeStringifyValue } from 'app/core/utils/explore';\nimport templateSrv from 'app/features/templating/template_srv';\nimport { getTimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport TableModel from 'app/core/table_model';\nimport { defaults } from 'lodash';\n\nexport const ANNOTATION_QUERY_STEP_DEFAULT = '60s';\n\nexport interface PromDataQueryResponse {\n  data: {\n    status: string;\n    data: {\n      resultType: string;\n      results?: DataQueryResponseData[];\n      result?: DataQueryResponseData[];\n    };\n  };\n  cancelled?: boolean;\n}\n\nexport interface PromLabelQueryResponse {\n  data: {\n    status: string;\n    data: string[];\n  };\n  cancelled?: boolean;\n}\n\nexport class PrometheusDatasource extends DataSourceApi<PromQuery, PromOptions> {\n  type: string;\n  editorSrc: string;\n  ruleMappings: { [index: string]: string };\n  url: string;\n  directUrl: string;\n  basicAuth: any;\n  withCredentials: any;\n  metricsNameCache: any;\n  interval: string;\n  queryTimeout: string;\n  httpMethod: string;\n  languageProvider: PrometheusLanguageProvider;\n  lookupsDisabled: boolean;\n  resultTransformer: ResultTransformer;\n  customQueryParameters: any;\n\n  constructor(instanceSettings: DataSourceInstanceSettings<PromOptions>) {\n    super(instanceSettings);\n\n    this.type = 'prometheus';\n    this.editorSrc = 'app/features/prometheus/partials/query.editor.html';\n    this.url = instanceSettings.url!;\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.interval = instanceSettings.jsonData.timeInterval || '15s';\n    this.queryTimeout = instanceSettings.jsonData.queryTimeout;\n    this.httpMethod = instanceSettings.jsonData.httpMethod || 'GET';\n    this.directUrl = instanceSettings.jsonData.directUrl;\n    this.resultTransformer = new ResultTransformer(templateSrv);\n    this.ruleMappings = {};\n    this.languageProvider = new PrometheusLanguageProvider(this);\n    this.lookupsDisabled = instanceSettings.jsonData.disableMetricsLookup ?? false;\n    this.customQueryParameters = new URLSearchParams(instanceSettings.jsonData.customQueryParameters);\n  }\n\n  init = () => {\n    this.loadRules();\n  };\n\n  getQueryDisplayText(query: PromQuery) {\n    return query.expr;\n  }\n\n  _addTracingHeaders(httpOptions: PromQueryRequest, options: DataQueryRequest<PromQuery>) {\n    httpOptions.headers = {};\n    const proxyMode = !this.url.match(/^http/);\n    if (proxyMode) {\n      httpOptions.headers['X-Dashboard-Id'] = options.dashboardId;\n      httpOptions.headers['X-Panel-Id'] = options.panelId;\n    }\n  }\n\n  _request<T = any>(url: string, data: Record<string, string> | null, overrides: Partial<BackendSrvRequest> = {}) {\n    const options: BackendSrvRequest = defaults(overrides, {\n      url: this.url + url,\n      method: this.httpMethod,\n      headers: {},\n    });\n\n    if (options.method === 'GET') {\n      if (data && Object.keys(data).length) {\n        options.url =\n          options.url +\n          '?' +\n          Object.entries(data)\n            .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)\n            .join('&');\n      }\n    } else {\n      options.headers!['Content-Type'] = 'application/x-www-form-urlencoded';\n      options.data = data;\n    }\n\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n\n    if (this.basicAuth) {\n      options.headers!.Authorization = this.basicAuth;\n    }\n\n    return getBackendSrv().fetch<T>(options);\n  }\n\n  // Use this for tab completion features, wont publish response to other components\n  metadataRequest<T = any>(url: string) {\n    return this._request<T>(url, null, { method: 'GET', hideFromInspector: true }).toPromise(); // toPromise until we change getTagValues, getTagKeys to Observable\n  }\n\n  interpolateQueryExpr(value: string | string[] = [], variable: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return prometheusRegularEscape(value);\n    }\n\n    if (typeof value === 'string') {\n      return prometheusSpecialRegexEscape(value);\n    }\n\n    const escapedValues = value.map(val => prometheusSpecialRegexEscape(val));\n\n    if (escapedValues.length === 1) {\n      return escapedValues[0];\n    }\n\n    return '(' + escapedValues.join('|') + ')';\n  }\n\n  targetContainsTemplate(target: PromQuery) {\n    return templateSrv.variableExists(target.expr);\n  }\n\n  processResult = (\n    response: any,\n    query: PromQueryRequest,\n    target: PromQuery,\n    responseListLength: number,\n    scopedVars?: ScopedVars\n  ) => {\n    // Keeping original start/end for transformers\n    const transformerOptions = {\n      format: target.format,\n      step: query.step,\n      legendFormat: target.legendFormat,\n      start: query.start,\n      end: query.end,\n      query: query.expr,\n      responseListLength,\n      scopedVars,\n      refId: target.refId,\n      valueWithRefId: target.valueWithRefId,\n      meta: {\n        /** Fix for showing of Prometheus results in Explore table. We want to show result of instant query in table and the rest of time series in graph */\n        preferredVisualisationType: query.instant ? 'table' : 'graph',\n      },\n    };\n    const series = this.resultTransformer.transform(response, transformerOptions);\n\n    return series;\n  };\n\n  prepareTargets = (options: DataQueryRequest<PromQuery>, start: number, end: number) => {\n    const queries: PromQueryRequest[] = [];\n    const activeTargets: PromQuery[] = [];\n\n    for (const target of options.targets) {\n      if (!target.expr || target.hide) {\n        continue;\n      }\n\n      target.requestId = options.panelId + target.refId;\n\n      if (options.app !== CoreApp.Explore) {\n        activeTargets.push(target);\n        queries.push(this.createQuery(target, options, start, end));\n        continue;\n      }\n\n      if (options.showingTable) {\n        // create instant target only if Table is showed in Explore\n        const instantTarget: any = cloneDeep(target);\n        instantTarget.format = 'table';\n        instantTarget.instant = true;\n        instantTarget.valueWithRefId = true;\n        delete instantTarget.maxDataPoints;\n        instantTarget.requestId += '_instant';\n\n        activeTargets.push(instantTarget);\n        queries.push(this.createQuery(instantTarget, options, start, end));\n      }\n\n      if (options.showingGraph) {\n        // create time series target only if Graph is showed in Explore\n        target.format = 'time_series';\n        target.instant = false;\n\n        activeTargets.push(target);\n        queries.push(this.createQuery(target, options, start, end));\n      }\n    }\n\n    return {\n      queries,\n      activeTargets,\n    };\n  };\n\n  query(options: DataQueryRequest<PromQuery>): Observable<DataQueryResponse> {\n    const start = this.getPrometheusTime(options.range.from, false);\n    const end = this.getPrometheusTime(options.range.to, true);\n    const { queries, activeTargets } = this.prepareTargets(options, start, end);\n\n    // No valid targets, return the empty result to save a round trip.\n    if (!queries || !queries.length) {\n      return of({\n        data: [],\n        state: LoadingState.Done,\n      });\n    }\n\n    if (options.app === CoreApp.Explore) {\n      return this.exploreQuery(queries, activeTargets, end);\n    }\n\n    return this.panelsQuery(queries, activeTargets, end, options.requestId, options.scopedVars);\n  }\n\n  private exploreQuery(queries: PromQueryRequest[], activeTargets: PromQuery[], end: number) {\n    let runningQueriesCount = queries.length;\n    const subQueries = queries.map((query, index) => {\n      const target = activeTargets[index];\n\n      let observable = query.instant\n        ? this.performInstantQuery(query, end)\n        : this.performTimeSeriesQuery(query, query.start, query.end);\n\n      return observable.pipe(\n        // Decrease the counter here. We assume that each request returns only single value and then completes\n        // (should hold until there is some streaming requests involved).\n        tap(() => runningQueriesCount--),\n        filter((response: any) => (response.cancelled ? false : true)),\n        map((response: any) => {\n          const data = this.processResult(response, query, target, queries.length);\n          return {\n            data,\n            key: query.requestId,\n            state: runningQueriesCount === 0 ? LoadingState.Done : LoadingState.Loading,\n          } as DataQueryResponse;\n        })\n      );\n    });\n\n    return merge(...subQueries);\n  }\n\n  private panelsQuery(\n    queries: PromQueryRequest[],\n    activeTargets: PromQuery[],\n    end: number,\n    requestId: string,\n    scopedVars: ScopedVars\n  ) {\n    const observables: Array<Observable<Array<TableModel | TimeSeries>>> = queries.map((query, index) => {\n      const target = activeTargets[index];\n\n      let observable = query.instant\n        ? this.performInstantQuery(query, end)\n        : this.performTimeSeriesQuery(query, query.start, query.end);\n\n      return observable.pipe(\n        filter((response: any) => (response.cancelled ? false : true)),\n        map((response: any) => {\n          const data = this.processResult(response, query, target, queries.length, scopedVars);\n          return data;\n        })\n      );\n    });\n\n    return forkJoin(observables).pipe(\n      map((results: Array<Array<TableModel | TimeSeries>>) => {\n        const data = results.reduce((result, current) => {\n          return [...result, ...current];\n        }, []);\n        return {\n          data,\n          key: requestId,\n          state: LoadingState.Done,\n        };\n      })\n    );\n  }\n\n  createQuery(target: PromQuery, options: DataQueryRequest<PromQuery>, start: number, end: number) {\n    const query: PromQueryRequest = {\n      hinting: target.hinting,\n      instant: target.instant,\n      step: 0,\n      expr: '',\n      requestId: target.requestId,\n      refId: target.refId,\n      start: 0,\n      end: 0,\n    };\n    const range = Math.ceil(end - start);\n\n    // options.interval is the dynamically calculated interval\n    let interval: number = rangeUtil.intervalToSeconds(options.interval);\n    // Minimum interval (\"Min step\"), if specified for the query, or same as interval otherwise.\n    const minInterval = rangeUtil.intervalToSeconds(\n      templateSrv.replace(target.interval || options.interval, options.scopedVars)\n    );\n    // Scrape interval as specified for the query (\"Min step\") or otherwise taken from the datasource.\n    // Min step field can have template variables in it, make sure to replace it.\n    const scrapeInterval = target.interval\n      ? rangeUtil.intervalToSeconds(templateSrv.replace(target.interval, options.scopedVars))\n      : rangeUtil.intervalToSeconds(this.interval);\n\n    const intervalFactor = target.intervalFactor || 1;\n    // Adjust the interval to take into account any specified minimum and interval factor plus Prometheus limits\n    const adjustedInterval = this.adjustInterval(interval, minInterval, range, intervalFactor);\n    let scopedVars = {\n      ...options.scopedVars,\n      ...this.getRangeScopedVars(options.range),\n      ...this.getRateIntervalScopedVariable(adjustedInterval, scrapeInterval),\n    };\n    // If the interval was adjusted, make a shallow copy of scopedVars with updated interval vars\n    if (interval !== adjustedInterval) {\n      interval = adjustedInterval;\n      scopedVars = Object.assign({}, options.scopedVars, {\n        __interval: { text: interval + 's', value: interval + 's' },\n        __interval_ms: { text: interval * 1000, value: interval * 1000 },\n        ...this.getRateIntervalScopedVariable(interval, scrapeInterval),\n        ...this.getRangeScopedVars(options.range),\n      });\n    }\n    query.step = interval;\n\n    let expr = target.expr;\n\n    // Apply adhoc filters\n    const adhocFilters = templateSrv.getAdhocFilters(this.name);\n    expr = adhocFilters.reduce((acc: string, filter: { key?: any; operator?: any; value?: any }) => {\n      const { key, operator } = filter;\n      let { value } = filter;\n      if (operator === '=~' || operator === '!~') {\n        value = prometheusRegularEscape(value);\n      }\n      return addLabelToQuery(acc, key, value, operator);\n    }, expr);\n\n    // Only replace vars in expression after having (possibly) updated interval vars\n    query.expr = templateSrv.replace(expr, scopedVars, this.interpolateQueryExpr);\n\n    // Align query interval with step to allow query caching and to ensure\n    // that about-same-time query results look the same.\n    const adjusted = alignRange(\n      start,\n      end,\n      query.step,\n      getTimeSrv()\n        .timeRange()\n        .to.utcOffset() * 60\n    );\n    query.start = adjusted.start;\n    query.end = adjusted.end;\n    this._addTracingHeaders(query, options);\n\n    return query;\n  }\n\n  getRateIntervalScopedVariable(interval: number, scrapeInterval: number) {\n    // Fall back to the default scrape interval of 15s if scrapeInterval is 0 for some reason.\n    if (scrapeInterval === 0) {\n      scrapeInterval = 15;\n    }\n    const rateInterval = Math.max(interval + scrapeInterval, 4 * scrapeInterval);\n    return { __rate_interval: { text: rateInterval + 's', value: rateInterval + 's' } };\n  }\n\n  adjustInterval(interval: number, minInterval: number, range: number, intervalFactor: number) {\n    // Prometheus will drop queries that might return more than 11000 data points.\n    // Calculate a safe interval as an additional minimum to take into account.\n    // Fractional safeIntervals are allowed, however serve little purpose if the interval is greater than 1\n    // If this is the case take the ceil of the value.\n    let safeInterval = range / 11000;\n    if (safeInterval > 1) {\n      safeInterval = Math.ceil(safeInterval);\n    }\n    return Math.max(interval * intervalFactor, minInterval, safeInterval);\n  }\n\n  performTimeSeriesQuery(query: PromQueryRequest, start: number, end: number) {\n    if (start > end) {\n      throw { message: 'Invalid time range' };\n    }\n\n    const url = '/api/v1/query_range';\n    const data: any = {\n      query: query.expr,\n      start,\n      end,\n      step: query.step,\n    };\n\n    if (this.queryTimeout) {\n      data['timeout'] = this.queryTimeout;\n    }\n\n    for (const [key, value] of this.customQueryParameters) {\n      if (data[key] == null) {\n        data[key] = value;\n      }\n    }\n\n    return this._request(url, data, { requestId: query.requestId, headers: query.headers }).pipe(\n      catchError(err => {\n        if (err.cancelled) {\n          return of(err);\n        }\n\n        return throwError(this.handleErrors(err, query));\n      })\n    );\n  }\n\n  performInstantQuery(query: PromQueryRequest, time: number) {\n    const url = '/api/v1/query';\n    const data: any = {\n      query: query.expr,\n      time,\n    };\n\n    if (this.queryTimeout) {\n      data['timeout'] = this.queryTimeout;\n    }\n\n    for (const [key, value] of this.customQueryParameters) {\n      if (data[key] == null) {\n        data[key] = value;\n      }\n    }\n\n    return this._request(url, data, { requestId: query.requestId, headers: query.headers }).pipe(\n      catchError(err => {\n        if (err.cancelled) {\n          return of(err);\n        }\n\n        return throwError(this.handleErrors(err, query));\n      })\n    );\n  }\n\n  handleErrors = (err: any, target: PromQuery) => {\n    const error: DataQueryError = {\n      message: (err && err.statusText) || 'Unknown error during query transaction. Please check JS console logs.',\n      refId: target.refId,\n    };\n\n    if (err.data) {\n      if (typeof err.data === 'string') {\n        error.message = err.data;\n      } else if (err.data.error) {\n        error.message = safeStringifyValue(err.data.error);\n      }\n    } else if (err.message) {\n      error.message = err.message;\n    } else if (typeof err === 'string') {\n      error.message = err;\n    }\n\n    error.status = err.status;\n    error.statusText = err.statusText;\n\n    return error;\n  };\n\n  async performSuggestQuery(query: string, cache = false) {\n    if (cache && this.metricsNameCache?.expire > Date.now()) {\n      return this.metricsNameCache.data.filter((metricName: any) => metricName.indexOf(query) !== 1);\n    }\n\n    const response: PromLabelQueryResponse = await this.metadataRequest('/api/v1/label/__name__/values');\n    this.metricsNameCache = {\n      data: response.data.data,\n      expire: Date.now() + 60 * 1000,\n    };\n\n    return response.data.data.filter(metricName => metricName.indexOf(query) !== 1);\n  }\n\n  metricFindQuery(query: string) {\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    const scopedVars = {\n      __interval: { text: this.interval, value: this.interval },\n      __interval_ms: { text: rangeUtil.intervalToMs(this.interval), value: rangeUtil.intervalToMs(this.interval) },\n      ...this.getRangeScopedVars(getTimeSrv().timeRange()),\n    };\n    const interpolated = templateSrv.replace(query, scopedVars, this.interpolateQueryExpr);\n    const metricFindQuery = new PrometheusMetricFindQuery(this, interpolated);\n    return metricFindQuery.process();\n  }\n\n  getRangeScopedVars(range: TimeRange = getTimeSrv().timeRange()) {\n    const msRange = range.to.diff(range.from);\n    const sRange = Math.round(msRange / 1000);\n    return {\n      __range_ms: { text: msRange, value: msRange },\n      __range_s: { text: sRange, value: sRange },\n      __range: { text: sRange + 's', value: sRange + 's' },\n    };\n  }\n\n  createAnnotationQueryOptions = (options: any): DataQueryRequest<PromQuery> => {\n    const annotation = options.annotation;\n    const interval =\n      annotation && annotation.step && typeof annotation.step === 'string'\n        ? annotation.step\n        : ANNOTATION_QUERY_STEP_DEFAULT;\n    return {\n      ...options,\n      interval,\n    };\n  };\n\n  async annotationQuery(options: any): Promise<AnnotationEvent[]> {\n    const annotation = options.annotation;\n    const { expr = '', tagKeys = '', titleFormat = '', textFormat = '' } = annotation;\n\n    if (!expr) {\n      return Promise.resolve([]);\n    }\n\n    const start = this.getPrometheusTime(options.range.from, false);\n    const end = this.getPrometheusTime(options.range.to, true);\n    const queryOptions = this.createAnnotationQueryOptions(options);\n\n    // Unsetting min interval for accurate event resolution\n    const minStep = '1s';\n    const queryModel = {\n      expr,\n      interval: minStep,\n      refId: 'X',\n      requestId: `prom-query-${annotation.name}`,\n    };\n\n    const query = this.createQuery(queryModel, queryOptions, start, end);\n\n    const self = this;\n    const response: PromDataQueryResponse = await this.performTimeSeriesQuery(\n      query,\n      query.start,\n      query.end\n    ).toPromise();\n    const eventList: AnnotationEvent[] = [];\n    const splitKeys = tagKeys.split(',');\n\n    if (response.cancelled) {\n      return [];\n    }\n\n    const step = Math.floor(query.step ?? 15) * 1000;\n\n    response?.data?.data?.result?.forEach(series => {\n      const tags = Object.entries(series.metric)\n        .filter(([k]) => splitKeys.includes(k))\n        .map(([_k, v]: [string, string]) => v);\n\n      series.values.forEach((value: any[]) => {\n        let timestampValue;\n        // rewrite timeseries to a common format\n        if (annotation.useValueForTime) {\n          timestampValue = Math.floor(parseFloat(value[1]));\n          value[1] = 1;\n        } else {\n          timestampValue = Math.floor(parseFloat(value[0])) * 1000;\n        }\n        value[0] = timestampValue;\n      });\n\n      const activeValues = series.values.filter((value: Record<number, string>) => parseFloat(value[1]) >= 1);\n      const activeValuesTimestamps: number[] = activeValues.map((value: number[]) => value[0]);\n\n      // Instead of creating singular annotation for each active event we group events into region if they are less\n      // then `step` apart.\n      let latestEvent: AnnotationEvent | null = null;\n\n      for (const timestamp of activeValuesTimestamps) {\n        // We already have event `open` and we have new event that is inside the `step` so we just update the end.\n        if (latestEvent && (latestEvent.timeEnd ?? 0) + step >= timestamp) {\n          latestEvent.timeEnd = timestamp;\n          continue;\n        }\n\n        // Event exists but new one is outside of the `step` so we \"finish\" the current region.\n        if (latestEvent) {\n          eventList.push(latestEvent);\n        }\n\n        // We start a new region.\n        latestEvent = {\n          time: timestamp,\n          timeEnd: timestamp,\n          annotation,\n          title: self.resultTransformer.renderTemplate(titleFormat, series.metric),\n          tags,\n          text: self.resultTransformer.renderTemplate(textFormat, series.metric),\n        };\n      }\n\n      if (latestEvent) {\n        // finish up last point if we have one\n        latestEvent.timeEnd = activeValuesTimestamps[activeValuesTimestamps.length - 1];\n        eventList.push(latestEvent);\n      }\n    });\n\n    return eventList;\n  }\n\n  async getTagKeys() {\n    const result = await this.metadataRequest('/api/v1/labels');\n    return result?.data?.data?.map((value: any) => ({ text: value })) ?? [];\n  }\n\n  async getTagValues(options: any = {}) {\n    const result = await this.metadataRequest(`/api/v1/label/${options.key}/values`);\n    return result?.data?.data?.map((value: any) => ({ text: value })) ?? [];\n  }\n\n  async testDatasource() {\n    const now = new Date().getTime();\n    const query = { expr: '1+1' } as PromQueryRequest;\n    const response = await this.performInstantQuery(query, now / 1000).toPromise();\n    return response.data.status === 'success'\n      ? { status: 'success', message: 'Data source is working' }\n      : { status: 'error', message: response.error };\n  }\n\n  interpolateVariablesInQueries(queries: PromQuery[], scopedVars: ScopedVars): PromQuery[] {\n    let expandedQueries = queries;\n    if (queries && queries.length) {\n      expandedQueries = queries.map(query => {\n        const expandedQuery = {\n          ...query,\n          datasource: this.name,\n          expr: templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr),\n        };\n        return expandedQuery;\n      });\n    }\n    return expandedQueries;\n  }\n\n  getQueryHints(query: PromQuery, result: any[]) {\n    return getQueryHints(query.expr ?? '', result, this);\n  }\n\n  async loadRules() {\n    try {\n      const res = await this.metadataRequest('/api/v1/rules');\n      const groups = res.data?.data?.groups;\n\n      if (groups) {\n        this.ruleMappings = extractRuleMappingFromGroups(groups);\n      }\n    } catch (e) {\n      console.log('Rules API is experimental. Ignore next error.');\n      console.error(e);\n    }\n  }\n\n  modifyQuery(query: PromQuery, action: any): PromQuery {\n    let expression = query.expr ?? '';\n    switch (action.type) {\n      case 'ADD_FILTER': {\n        expression = addLabelToQuery(expression, action.key, action.value);\n        break;\n      }\n      case 'ADD_FILTER_OUT': {\n        expression = addLabelToQuery(expression, action.key, action.value, '!=');\n        break;\n      }\n      case 'ADD_HISTOGRAM_QUANTILE': {\n        expression = `histogram_quantile(0.95, sum(rate(${expression}[5m])) by (le))`;\n        break;\n      }\n      case 'ADD_RATE': {\n        expression = `rate(${expression}[5m])`;\n        break;\n      }\n      case 'ADD_SUM': {\n        expression = `sum(${expression.trim()}) by ($1)`;\n        break;\n      }\n      case 'EXPAND_RULES': {\n        if (action.mapping) {\n          expression = expandRecordingRules(expression, action.mapping);\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    return { ...query, expr: expression };\n  }\n\n  getPrometheusTime(date: string | DateTime, roundUp: boolean) {\n    if (typeof date === 'string') {\n      date = dateMath.parse(date, roundUp)!;\n    }\n\n    return Math.ceil(date.valueOf() / 1000);\n  }\n\n  getTimeRange(): { start: number; end: number } {\n    const range = getTimeSrv().timeRange();\n    return {\n      start: this.getPrometheusTime(range.from, false),\n      end: this.getPrometheusTime(range.to, true),\n    };\n  }\n\n  getOriginalMetricName(labelData: { [key: string]: string }) {\n    return this.resultTransformer.getOriginalMetricName(labelData);\n  }\n}\n\n/**\n * Align query range to step.\n * Rounds start and end down to a multiple of step.\n * @param start Timestamp marking the beginning of the range.\n * @param end Timestamp marking the end of the range.\n * @param step Interval to align start and end with.\n * @param utcOffsetSec Number of seconds current timezone is offset from UTC\n */\nexport function alignRange(\n  start: number,\n  end: number,\n  step: number,\n  utcOffsetSec: number\n): { end: number; start: number } {\n  const alignedEnd = Math.floor((end + utcOffsetSec) / step) * step - utcOffsetSec;\n  const alignedStart = Math.floor((start + utcOffsetSec) / step) * step - utcOffsetSec;\n  return {\n    end: alignedEnd,\n    start: alignedStart,\n  };\n}\n\nexport function extractRuleMappingFromGroups(groups: any[]) {\n  return groups.reduce(\n    (mapping, group) =>\n      group.rules\n        .filter((rule: any) => rule.type === 'recording')\n        .reduce(\n          (acc: { [key: string]: string }, rule: any) => ({\n            ...acc,\n            [rule.name]: rule.query,\n          }),\n          mapping\n        ),\n    {}\n  );\n}\n\nexport function prometheusRegularEscape(value: any) {\n  return typeof value === 'string' ? value.replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"\\\\\\\\'\") : value;\n}\n\nexport function prometheusSpecialRegexEscape(value: any) {\n  return typeof value === 'string' ? value.replace(/\\\\/g, '\\\\\\\\\\\\\\\\').replace(/[$^*{}\\[\\]\\'+?.()|]/g, '\\\\\\\\$&') : value;\n}\n","import _ from 'lodash';\nimport React, { ReactNode } from 'react';\n\nimport { Plugin } from 'slate';\nimport {\n  ButtonCascader,\n  CascaderOption,\n  SlatePrism,\n  TypeaheadInput,\n  TypeaheadOutput,\n  QueryField,\n  BracesPlugin,\n} from '@grafana/ui';\n\nimport Prism from 'prismjs';\n\n// dom also includes Element polyfills\nimport { PromQuery, PromOptions, PromMetricsMetadata } from '../types';\nimport { CancelablePromise, makePromiseCancelable } from 'app/core/utils/CancelablePromise';\nimport { ExploreQueryFieldProps, QueryHint, isDataFrame, toLegacyResponseData, HistoryItem } from '@grafana/data';\nimport { DOMUtil, SuggestionsState } from '@grafana/ui';\nimport { PrometheusDatasource } from '../datasource';\n\nconst HISTOGRAM_GROUP = '__histograms__';\nconst PRISM_SYNTAX = 'promql';\nexport const RECORDING_RULES_GROUP = '__recording_rules__';\n\nfunction getChooserText(metricsLookupDisabled: boolean, hasSyntax: boolean, metrics: string[]) {\n  if (metricsLookupDisabled) {\n    return '(Disabled)';\n  }\n\n  if (!hasSyntax) {\n    return 'Loading metrics...';\n  }\n\n  if (metrics && metrics.length === 0) {\n    return '(No metrics found)';\n  }\n\n  return 'Metrics';\n}\n\nfunction addMetricsMetadata(metric: string, metadata?: PromMetricsMetadata): CascaderOption {\n  const option: CascaderOption = { label: metric, value: metric };\n  if (metadata && metadata[metric]) {\n    const { type = '', help } = metadata[metric][0];\n    option.title = [metric, type.toUpperCase(), help].join('\\n');\n  }\n  return option;\n}\n\nexport function groupMetricsByPrefix(metrics: string[], metadata?: PromMetricsMetadata): CascaderOption[] {\n  // Filter out recording rules and insert as first option\n  const ruleRegex = /:\\w+:/;\n  const ruleNames = metrics.filter(metric => ruleRegex.test(metric));\n  const rulesOption = {\n    label: 'Recording rules',\n    value: RECORDING_RULES_GROUP,\n    children: ruleNames\n      .slice()\n      .sort()\n      .map(name => ({ label: name, value: name })),\n  };\n\n  const options = ruleNames.length > 0 ? [rulesOption] : [];\n\n  const delimiter = '_';\n  const metricsOptions = _.chain(metrics)\n    .filter((metric: string) => !ruleRegex.test(metric))\n    .groupBy((metric: string) => metric.split(delimiter)[0])\n    .map(\n      (metricsForPrefix: string[], prefix: string): CascaderOption => {\n        const prefixIsMetric = metricsForPrefix.length === 1 && metricsForPrefix[0] === prefix;\n        const children = prefixIsMetric ? [] : metricsForPrefix.sort().map(m => addMetricsMetadata(m, metadata));\n        return {\n          children,\n          label: prefix,\n          value: prefix,\n        };\n      }\n    )\n    .sortBy('label')\n    .value();\n\n  return [...options, ...metricsOptions];\n}\n\nexport function willApplySuggestion(suggestion: string, { typeaheadContext, typeaheadText }: SuggestionsState): string {\n  // Modify suggestion based on context\n  switch (typeaheadContext) {\n    case 'context-labels': {\n      const nextChar = DOMUtil.getNextCharacter();\n      if (!nextChar || nextChar === '}' || nextChar === ',') {\n        suggestion += '=';\n      }\n      break;\n    }\n\n    case 'context-label-values': {\n      // Always add quotes and remove existing ones instead\n      if (!typeaheadText.match(/^(!?=~?\"|\")/)) {\n        suggestion = `\"${suggestion}`;\n      }\n      if (DOMUtil.getNextCharacter() !== '\"') {\n        suggestion = `${suggestion}\"`;\n      }\n      break;\n    }\n\n    default:\n  }\n  return suggestion;\n}\n\ninterface PromQueryFieldProps extends ExploreQueryFieldProps<PrometheusDatasource, PromQuery, PromOptions> {\n  history: Array<HistoryItem<PromQuery>>;\n  ExtraFieldElement?: ReactNode;\n}\n\ninterface PromQueryFieldState {\n  metricsOptions: any[];\n  syntaxLoaded: boolean;\n  hint: QueryHint | null;\n}\n\nclass PromQueryField extends React.PureComponent<PromQueryFieldProps, PromQueryFieldState> {\n  plugins: Plugin[];\n  languageProviderInitializationPromise: CancelablePromise<any>;\n\n  constructor(props: PromQueryFieldProps, context: React.Context<any>) {\n    super(props, context);\n\n    this.plugins = [\n      BracesPlugin(),\n      SlatePrism({\n        onlyIn: (node: any) => node.type === 'code_block',\n        getSyntax: (node: any) => 'promql',\n      }),\n    ];\n\n    this.state = {\n      metricsOptions: [],\n      syntaxLoaded: false,\n      hint: null,\n    };\n  }\n\n  componentDidMount() {\n    if (this.props.datasource.languageProvider) {\n      this.refreshMetrics();\n    }\n    this.refreshHint();\n  }\n\n  componentWillUnmount() {\n    if (this.languageProviderInitializationPromise) {\n      this.languageProviderInitializationPromise.cancel();\n    }\n  }\n\n  componentDidUpdate(prevProps: PromQueryFieldProps) {\n    const {\n      data,\n      datasource: { languageProvider },\n    } = this.props;\n\n    if (languageProvider !== prevProps.datasource.languageProvider) {\n      this.refreshMetrics();\n    }\n\n    if (data && prevProps.data && prevProps.data.series !== data.series) {\n      this.refreshHint();\n    }\n  }\n\n  refreshHint = () => {\n    const { datasource, query, data } = this.props;\n\n    if (!data || data.series.length === 0) {\n      this.setState({ hint: null });\n      return;\n    }\n\n    const result = isDataFrame(data.series[0]) ? data.series.map(toLegacyResponseData) : data.series;\n    const hints = datasource.getQueryHints(query, result);\n    const hint = hints.length > 0 ? hints[0] : null;\n    this.setState({ hint });\n  };\n\n  refreshMetrics = () => {\n    const {\n      datasource: { languageProvider },\n    } = this.props;\n\n    this.setState({\n      syntaxLoaded: false,\n    });\n\n    Prism.languages[PRISM_SYNTAX] = languageProvider.syntax;\n    this.languageProviderInitializationPromise = makePromiseCancelable(languageProvider.start());\n    this.languageProviderInitializationPromise.promise\n      .then(remaining => {\n        remaining.map((task: Promise<any>) => task.then(this.onUpdateLanguage).catch(() => {}));\n      })\n      .then(() => this.onUpdateLanguage())\n      .catch(err => {\n        if (!err.isCanceled) {\n          throw err;\n        }\n      });\n  };\n\n  onChangeMetrics = (values: string[], selectedOptions: CascaderOption[]) => {\n    let query;\n    if (selectedOptions.length === 1) {\n      const selectedOption = selectedOptions[0];\n      if (!selectedOption.children || selectedOption.children.length === 0) {\n        query = selectedOption.value;\n      } else {\n        // Ignore click on group\n        return;\n      }\n    } else {\n      const prefix = selectedOptions[0].value;\n      const metric = selectedOptions[1].value;\n      if (prefix === HISTOGRAM_GROUP) {\n        query = `histogram_quantile(0.95, sum(rate(${metric}[5m])) by (le))`;\n      } else {\n        query = metric;\n      }\n    }\n    this.onChangeQuery(query, true);\n  };\n\n  onChangeQuery = (value: string, override?: boolean) => {\n    // Send text change to parent\n    const { query, onChange, onRunQuery } = this.props;\n    if (onChange) {\n      const nextQuery: PromQuery = { ...query, expr: value };\n      onChange(nextQuery);\n\n      if (override && onRunQuery) {\n        onRunQuery();\n      }\n    }\n  };\n\n  onClickHintFix = () => {\n    const { datasource, query, onChange, onRunQuery } = this.props;\n    const { hint } = this.state;\n\n    onChange(datasource.modifyQuery(query, hint!.fix!.action));\n    onRunQuery();\n  };\n\n  onUpdateLanguage = () => {\n    const {\n      datasource,\n      datasource: { languageProvider },\n    } = this.props;\n    const { histogramMetrics, metrics, metricsMetadata, lookupMetricsThreshold } = languageProvider;\n\n    if (!metrics) {\n      return;\n    }\n\n    // Build metrics tree\n    const metricsByPrefix = groupMetricsByPrefix(metrics, metricsMetadata);\n    const histogramOptions = histogramMetrics.map((hm: any) => ({ label: hm, value: hm }));\n    const metricsOptions =\n      histogramMetrics.length > 0\n        ? [\n            { label: 'Histograms', value: HISTOGRAM_GROUP, children: histogramOptions, isLeaf: false },\n            ...metricsByPrefix,\n          ]\n        : metricsByPrefix;\n\n    // Hint for big disabled lookups\n    let hint: QueryHint | null = null;\n\n    if (!datasource.lookupsDisabled && languageProvider.lookupsDisabled) {\n      hint = {\n        label: `Dynamic label lookup is disabled for datasources with more than ${lookupMetricsThreshold} metrics.`,\n        type: 'INFO',\n      };\n    }\n\n    this.setState({ hint, metricsOptions, syntaxLoaded: true });\n  };\n\n  onTypeahead = async (typeahead: TypeaheadInput): Promise<TypeaheadOutput> => {\n    const {\n      datasource: { languageProvider },\n    } = this.props;\n\n    if (!languageProvider) {\n      return { suggestions: [] };\n    }\n\n    const { history } = this.props;\n    const { prefix, text, value, wrapperClasses, labelKey } = typeahead;\n\n    const result = await languageProvider.provideCompletionItems(\n      { text, value, prefix, wrapperClasses, labelKey },\n      { history }\n    );\n\n    // console.log('handleTypeahead', wrapperClasses, text, prefix, labelKey, result.context);\n\n    return result;\n  };\n\n  render() {\n    const {\n      datasource,\n      datasource: { languageProvider },\n      query,\n      ExtraFieldElement,\n    } = this.props;\n    const { metricsOptions, syntaxLoaded, hint } = this.state;\n    const cleanText = languageProvider ? languageProvider.cleanText : undefined;\n    const chooserText = getChooserText(datasource.lookupsDisabled, syntaxLoaded, metricsOptions);\n    const buttonDisabled = !(syntaxLoaded && metricsOptions && metricsOptions.length > 0);\n\n    return (\n      <>\n        <div className=\"gf-form-inline gf-form-inline--xs-view-flex-column flex-grow-1\">\n          <div className=\"gf-form flex-shrink-0\">\n            <ButtonCascader options={metricsOptions} disabled={buttonDisabled} onChange={this.onChangeMetrics}>\n              {chooserText}\n            </ButtonCascader>\n          </div>\n          <div className={'gf-form gf-form--grow flex-shrink-1 min-width-15 explore-input-margin'}>\n            <QueryField\n              additionalPlugins={this.plugins}\n              cleanText={cleanText}\n              query={query.expr}\n              onTypeahead={this.onTypeahead}\n              onWillApplySuggestion={willApplySuggestion}\n              onBlur={this.props.onBlur}\n              onChange={this.onChangeQuery}\n              onRunQuery={this.props.onRunQuery}\n              placeholder=\"Enter a PromQL query (run with Shift+Enter)\"\n              portalOrigin=\"prometheus\"\n              syntaxLoaded={syntaxLoaded}\n            />\n          </div>\n          {ExtraFieldElement}\n        </div>\n        {hint ? (\n          <div className=\"query-row-break\">\n            <div className=\"prom-query-field-info text-warning\">\n              {hint.label}{' '}\n              {hint.fix ? (\n                <a className=\"text-link muted\" onClick={this.onClickHintFix}>\n                  {hint.fix.label}\n                </a>\n              ) : null}\n            </div>\n          </div>\n        ) : null}\n      </>\n    );\n  }\n}\n\nexport default PromQueryField;\n","import _ from 'lodash';\nimport React, { Component } from 'react';\n\nimport { PrometheusDatasource } from '../datasource';\nimport { PromQuery } from '../types';\nimport { DataQueryRequest, PanelData } from '@grafana/data';\n\ninterface Props {\n  datasource: PrometheusDatasource;\n  query: PromQuery;\n  panelData?: PanelData;\n}\n\ninterface State {\n  href: string;\n}\n\nexport default class PromLink extends Component<Props, State> {\n  state: State = { href: '' };\n\n  async componentDidUpdate(prevProps: Props) {\n    const { panelData } = this.props;\n\n    if (panelData && panelData.request && prevProps.panelData !== panelData) {\n      const href = await this.getExternalLink(panelData);\n      this.setState({ href });\n    }\n  }\n\n  async getExternalLink(panelData: PanelData): Promise<string> {\n    const { query, datasource } = this.props;\n    const { request } = panelData;\n\n    if (!request) {\n      return '';\n    }\n\n    const range = request.range;\n    const start = datasource.getPrometheusTime(range.from, false);\n    const end = datasource.getPrometheusTime(range.to, true);\n    const rangeDiff = Math.ceil(end - start);\n    const endTime = range.to.utc().format('YYYY-MM-DD HH:mm');\n\n    const options = {\n      interval: request.interval,\n    } as DataQueryRequest<PromQuery>;\n\n    const queryOptions = datasource.createQuery(query, options, start, end);\n    const expr = {\n      'g0.expr': queryOptions.expr,\n      'g0.range_input': rangeDiff + 's',\n      'g0.end_input': endTime,\n      'g0.step_input': queryOptions.step,\n      'g0.tab': 0,\n    };\n\n    const args = _.map(expr, (v: string, k: string) => {\n      return k + '=' + encodeURIComponent(v);\n    }).join('&');\n    return `${datasource.directUrl}/graph?${args}`;\n  }\n\n  render() {\n    const { href } = this.state;\n\n    return (\n      <a href={href} target=\"_blank\" rel=\"noopener\">\n        Prometheus\n      </a>\n    );\n  }\n}\n","import _ from 'lodash';\nimport React, { PureComponent } from 'react';\n\n// Types\nimport { InlineFormLabel, LegacyForms, Select } from '@grafana/ui';\nimport { SelectableValue, QueryEditorProps } from '@grafana/data';\n\nconst { Switch } = LegacyForms;\n\nimport { PrometheusDatasource } from '../datasource';\nimport { PromQuery, PromOptions } from '../types';\n\nimport PromQueryField from './PromQueryField';\nimport PromLink from './PromLink';\nexport type Props = QueryEditorProps<PrometheusDatasource, PromQuery, PromOptions>;\n\nconst FORMAT_OPTIONS: Array<SelectableValue<string>> = [\n  { label: 'Time series', value: 'time_series' },\n  { label: 'Table', value: 'table' },\n  { label: 'Heatmap', value: 'heatmap' },\n];\n\nconst INTERVAL_FACTOR_OPTIONS: Array<SelectableValue<number>> = _.map([1, 2, 3, 4, 5, 10], (value: number) => ({\n  value,\n  label: '1/' + value,\n}));\n\ninterface State {\n  legendFormat?: string;\n  formatOption: SelectableValue<string>;\n  interval?: string;\n  intervalFactorOption: SelectableValue<number>;\n  instant: boolean;\n}\n\nexport class PromQueryEditor extends PureComponent<Props, State> {\n  // Query target to be modified and used for queries\n  query: PromQuery;\n\n  constructor(props: Props) {\n    super(props);\n    // Use default query to prevent undefined input values\n    const defaultQuery: Partial<PromQuery> = { expr: '', legendFormat: '', interval: '' };\n    const query = Object.assign({}, defaultQuery, props.query);\n    this.query = query;\n    // Query target properties that are fully controlled inputs\n    this.state = {\n      // Fully controlled text inputs\n      interval: query.interval,\n      legendFormat: query.legendFormat,\n      // Select options\n      formatOption: FORMAT_OPTIONS.find(option => option.value === query.format) || FORMAT_OPTIONS[0],\n      intervalFactorOption:\n        INTERVAL_FACTOR_OPTIONS.find(option => option.value === query.intervalFactor) || INTERVAL_FACTOR_OPTIONS[0],\n      // Switch options\n      instant: Boolean(query.instant),\n    };\n  }\n\n  onFieldChange = (query: PromQuery, override?: any) => {\n    this.query.expr = query.expr;\n  };\n\n  onFormatChange = (option: SelectableValue<string>) => {\n    this.query.format = option.value;\n    this.setState({ formatOption: option }, this.onRunQuery);\n  };\n\n  onInstantChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const instant = e.target.checked;\n    this.query.instant = instant;\n    this.setState({ instant }, this.onRunQuery);\n  };\n\n  onIntervalChange = (e: React.SyntheticEvent<HTMLInputElement>) => {\n    const interval = e.currentTarget.value;\n    this.query.interval = interval;\n    this.setState({ interval });\n  };\n\n  onIntervalFactorChange = (option: SelectableValue<number>) => {\n    this.query.intervalFactor = option.value;\n    this.setState({ intervalFactorOption: option }, this.onRunQuery);\n  };\n\n  onLegendChange = (e: React.SyntheticEvent<HTMLInputElement>) => {\n    const legendFormat = e.currentTarget.value;\n    this.query.legendFormat = legendFormat;\n    this.setState({ legendFormat });\n  };\n\n  onRunQuery = () => {\n    const { query } = this;\n    this.props.onChange(query);\n    this.props.onRunQuery();\n  };\n\n  render() {\n    const { datasource, query, data } = this.props;\n    const { formatOption, instant, interval, intervalFactorOption, legendFormat } = this.state;\n\n    return (\n      <div>\n        <PromQueryField\n          datasource={datasource}\n          query={query}\n          onRunQuery={this.onRunQuery}\n          onChange={this.onFieldChange}\n          history={[]}\n          data={data}\n        />\n\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              width={7}\n              tooltip=\"Controls the name of the time series, using name or pattern. For example\n        {{hostname}} will be replaced with label value for the label hostname.\"\n            >\n              Legend\n            </InlineFormLabel>\n            <input\n              type=\"text\"\n              className=\"gf-form-input\"\n              placeholder=\"legend format\"\n              value={legendFormat}\n              onChange={this.onLegendChange}\n              onBlur={this.onRunQuery}\n            />\n          </div>\n\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              width={7}\n              tooltip={\n                <>\n                  An additional lower limit for the step parameter of the Prometheus query and for the{' '}\n                  <code>$__interval</code> and <code>$__rate_interval</code> variables. The limit is absolute and not\n                  modified by the \"Resolution\" setting.\n                </>\n              }\n            >\n              Min step\n            </InlineFormLabel>\n            <input\n              type=\"text\"\n              className=\"gf-form-input width-8\"\n              placeholder={interval}\n              onChange={this.onIntervalChange}\n              onBlur={this.onRunQuery}\n              value={interval}\n            />\n          </div>\n\n          <div className=\"gf-form\">\n            <div className=\"gf-form-label\">Resolution</div>\n            <Select\n              isSearchable={false}\n              menuPlacement=\"bottom\"\n              options={INTERVAL_FACTOR_OPTIONS}\n              onChange={this.onIntervalFactorChange}\n              value={intervalFactorOption}\n            />\n          </div>\n\n          <div className=\"gf-form\">\n            <div className=\"gf-form-label width-7\">Format</div>\n            <Select\n              width={16}\n              isSearchable={false}\n              options={FORMAT_OPTIONS}\n              onChange={this.onFormatChange}\n              value={formatOption}\n            />\n            <Switch label=\"Instant\" checked={instant} onChange={this.onInstantChange} />\n\n            <InlineFormLabel width={10} tooltip=\"Link to Graph in Prometheus\">\n              <PromLink\n                datasource={datasource}\n                query={this.query} // Use modified query\n                panelData={data}\n              />\n            </InlineFormLabel>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n","import React from 'react';\nimport { ExploreStartPageProps, DataQuery } from '@grafana/data';\n\nconst CHEAT_SHEET_ITEMS = [\n  {\n    title: 'Request Rate',\n    expression: 'rate(http_request_total[5m])',\n    label:\n      'Given an HTTP request counter, this query calculates the per-second average request rate over the last 5 minutes.',\n  },\n  {\n    title: '95th Percentile of Request Latencies',\n    expression: 'histogram_quantile(0.95, sum(rate(prometheus_http_request_duration_seconds_bucket[5m])) by (le))',\n    label: 'Calculates the 95th percentile of HTTP request rate over 5 minute windows.',\n  },\n  {\n    title: 'Alerts Firing',\n    expression: 'sort_desc(sum(sum_over_time(ALERTS{alertstate=\"firing\"}[24h])) by (alertname))',\n    label: 'Sums up the alerts that have been firing over the last 24 hours.',\n  },\n  {\n    title: 'Step',\n    label:\n      'Defines the graph resolution using a duration format (15s, 1m, 3h, ...). Small steps create high-resolution graphs but can be slow over larger time ranges. Using a longer step lowers the resolution and smooths the graph by producing fewer datapoints. If no step is given the resolution is calculated automatically.',\n  },\n];\n\nexport default (props: ExploreStartPageProps) => (\n  <div>\n    <h2>PromQL Cheat Sheet</h2>\n    {CHEAT_SHEET_ITEMS.map((item, index) => (\n      <div className=\"cheat-sheet-item\" key={index}>\n        <div className=\"cheat-sheet-item__title\">{item.title}</div>\n        {item.expression ? (\n          <div\n            className=\"cheat-sheet-item__example\"\n            onClick={e => props.onClickExample({ refId: 'A', expr: item.expression } as DataQuery)}\n          >\n            <code>{item.expression}</code>\n          </div>\n        ) : null}\n        <div className=\"cheat-sheet-item__label\">{item.label}</div>\n      </div>\n    ))}\n  </div>\n);\n","// Libraries\nimport React, { memo } from 'react';\n\n// Types\nimport { InlineFormLabel } from '@grafana/ui';\n\nexport interface PromExploreExtraFieldProps {\n  label: string;\n  onChangeFunc: (e: React.SyntheticEvent<HTMLInputElement>) => void;\n  onKeyDownFunc: (e: React.KeyboardEvent<HTMLInputElement>) => void;\n  value: string;\n  hasTooltip?: boolean;\n  tooltipContent?: string;\n}\n\nexport function PromExploreExtraField(props: PromExploreExtraFieldProps) {\n  const { label, onChangeFunc, onKeyDownFunc, value, hasTooltip, tooltipContent } = props;\n\n  return (\n    <div className=\"gf-form-inline\" aria-label=\"Prometheus extra field\">\n      <div className=\"gf-form\">\n        <InlineFormLabel width={5} tooltip={hasTooltip ? tooltipContent : undefined}>\n          {label}\n        </InlineFormLabel>\n        <input\n          type={'text'}\n          className=\"gf-form-input width-4\"\n          placeholder={'auto'}\n          onChange={onChangeFunc}\n          onKeyDown={onKeyDownFunc}\n          value={value}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default memo(PromExploreExtraField);\n","import React, { memo, FC } from 'react';\n\n// Types\nimport { ExploreQueryFieldProps } from '@grafana/data';\n\nimport { PrometheusDatasource } from '../datasource';\nimport { PromQuery, PromOptions } from '../types';\n\nimport PromQueryField from './PromQueryField';\nimport { PromExploreExtraField } from './PromExploreExtraField';\n\nexport type Props = ExploreQueryFieldProps<PrometheusDatasource, PromQuery, PromOptions>;\n\nexport const PromExploreQueryEditor: FC<Props> = (props: Props) => {\n  const { query, data, datasource, history, onChange, onRunQuery } = props;\n\n  function onChangeQueryStep(value: string) {\n    const { query, onChange } = props;\n    const nextQuery = { ...query, interval: value };\n    onChange(nextQuery);\n  }\n\n  function onStepChange(e: React.SyntheticEvent<HTMLInputElement>) {\n    if (e.currentTarget.value !== query.interval) {\n      onChangeQueryStep(e.currentTarget.value);\n    }\n  }\n\n  function onReturnKeyDown(e: React.KeyboardEvent<HTMLInputElement>) {\n    if (e.key === 'Enter') {\n      onRunQuery();\n    }\n  }\n\n  return (\n    <PromQueryField\n      datasource={datasource}\n      query={query}\n      onRunQuery={onRunQuery}\n      onChange={onChange}\n      onBlur={() => {}}\n      history={history}\n      data={data}\n      ExtraFieldElement={\n        <PromExploreExtraField\n          label={'Step'}\n          onChangeFunc={onStepChange}\n          onKeyDownFunc={onReturnKeyDown}\n          value={query.interval || ''}\n          hasTooltip={true}\n          tooltipContent={\n            'Time units can be used here, for example: 5s, 1m, 3h, 1d, 1y (Default if no unit is specified: s)'\n          }\n        />\n      }\n    />\n  );\n};\n\nexport default memo(PromExploreQueryEditor);\n","import React, { SyntheticEvent } from 'react';\nimport { EventsWithValidation, InlineFormLabel, regexValidation, LegacyForms } from '@grafana/ui';\nconst { Select, Input, FormField, Switch } = LegacyForms;\nimport {\n  SelectableValue,\n  onUpdateDatasourceJsonDataOptionChecked,\n  DataSourcePluginOptionsEditorProps,\n} from '@grafana/data';\nimport { PromOptions } from '../types';\n\nconst httpOptions = [\n  { value: 'GET', label: 'GET' },\n  { value: 'POST', label: 'POST' },\n];\n\ntype Props = Pick<DataSourcePluginOptionsEditorProps<PromOptions>, 'options' | 'onOptionsChange'>;\n\nexport const PromSettings = (props: Props) => {\n  const { options, onOptionsChange } = props;\n\n  return (\n    <>\n      <div className=\"gf-form-group\">\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <FormField\n              label=\"Scrape interval\"\n              labelWidth={13}\n              inputEl={\n                <Input\n                  className=\"width-6\"\n                  value={options.jsonData.timeInterval}\n                  spellCheck={false}\n                  placeholder=\"15s\"\n                  onChange={onChangeHandler('timeInterval', options, onOptionsChange)}\n                  validationEvents={promSettingsValidationEvents}\n                />\n              }\n              tooltip=\"Set this to the typical scrape and evaluation interval configured in Prometheus. Defaults to 15s.\"\n            />\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <FormField\n              label=\"Query timeout\"\n              labelWidth={13}\n              inputEl={\n                <Input\n                  className=\"width-6\"\n                  value={options.jsonData.queryTimeout}\n                  onChange={onChangeHandler('queryTimeout', options, onOptionsChange)}\n                  spellCheck={false}\n                  placeholder=\"60s\"\n                  validationEvents={promSettingsValidationEvents}\n                />\n              }\n              tooltip=\"Set the Prometheus query timeout.\"\n            />\n          </div>\n        </div>\n        <div className=\"gf-form\">\n          <InlineFormLabel\n            width={13}\n            tooltip=\"Specify the HTTP Method to query Prometheus. (POST is only available in Prometheus >= v2.1.0)\"\n          >\n            HTTP Method\n          </InlineFormLabel>\n          <Select\n            options={httpOptions}\n            value={httpOptions.find(o => o.value === options.jsonData.httpMethod)}\n            onChange={onChangeHandler('httpMethod', options, onOptionsChange)}\n            width={7}\n          />\n        </div>\n      </div>\n      <h3 className=\"page-heading\">Misc</h3>\n      <div className=\"gf-form-group\">\n        <div className=\"gf-form\">\n          <Switch\n            checked={options.jsonData.disableMetricsLookup ?? false}\n            label=\"Disable metrics lookup\"\n            labelClass=\"width-14\"\n            onChange={onUpdateDatasourceJsonDataOptionChecked(props, 'disableMetricsLookup')}\n            tooltip=\"Checking this option will disable the metrics chooser and metric/label support in the query field's autocomplete. This helps if you have performance issues with bigger Prometheus instances.\"\n          />\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form max-width-30\">\n            <FormField\n              label=\"Custom query parameters\"\n              labelWidth={14}\n              tooltip=\"Add Custom parameters to Prometheus or Thanos queries.\"\n              inputEl={\n                <Input\n                  className=\"width-25\"\n                  value={options.jsonData.customQueryParameters}\n                  onChange={onChangeHandler('customQueryParameters', options, onOptionsChange)}\n                  spellCheck={false}\n                  placeholder=\"Example: max_source_resolution=5m&timeout=10\"\n                />\n              }\n            />\n          </div>\n        </div>\n      </div>\n    </>\n  );\n};\n\nexport const promSettingsValidationEvents = {\n  [EventsWithValidation.onBlur]: [\n    regexValidation(\n      /^$|^\\d+(ms|[Mwdhmsy])$/,\n      'Value is not valid, you can use number with time unit specifier: y, M, w, d, h, m, s'\n    ),\n  ],\n};\n\nexport const getValueFromEventItem = (eventItem: SyntheticEvent<HTMLInputElement> | SelectableValue<string>) => {\n  if (!eventItem) {\n    return '';\n  }\n\n  if (eventItem.hasOwnProperty('currentTarget')) {\n    return eventItem.currentTarget.value;\n  }\n\n  return (eventItem as SelectableValue<string>).value;\n};\n\nconst onChangeHandler = (\n  key: keyof PromOptions,\n  options: Props['options'],\n  onOptionsChange: Props['onOptionsChange']\n) => (eventItem: SyntheticEvent<HTMLInputElement> | SelectableValue<string>) => {\n  onOptionsChange({\n    ...options,\n    jsonData: {\n      ...options.jsonData,\n      [key]: getValueFromEventItem(eventItem),\n    },\n  });\n};\n","import { DataSourcePlugin } from '@grafana/data';\nimport { ANNOTATION_QUERY_STEP_DEFAULT, PrometheusDatasource } from './datasource';\n\nimport { PromQueryEditor } from './components/PromQueryEditor';\nimport PromCheatSheet from './components/PromCheatSheet';\nimport PromExploreQueryEditor from './components/PromExploreQueryEditor';\n\nimport { ConfigEditor } from './configuration/ConfigEditor';\n\nclass PrometheusAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n  stepDefaultValuePlaceholder = ANNOTATION_QUERY_STEP_DEFAULT;\n}\n\nexport const plugin = new DataSourcePlugin(PrometheusDatasource)\n  .setQueryEditor(PromQueryEditor)\n  .setConfigEditor(ConfigEditor)\n  .setExploreMetricsQueryField(PromExploreQueryEditor)\n  .setAnnotationQueryCtrl(PrometheusAnnotationsQueryCtrl)\n  .setExploreStartPage(PromCheatSheet);\n","import React from 'react';\nimport { DataSourceHttpSettings } from '@grafana/ui';\nimport { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { PromSettings } from './PromSettings';\nimport { PromOptions } from '../types';\n\nexport type Props = DataSourcePluginOptionsEditorProps<PromOptions>;\nexport const ConfigEditor = (props: Props) => {\n  const { options, onOptionsChange } = props;\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl=\"http://localhost:9090\"\n        dataSourceConfig={options}\n        showAccessOptions={true}\n        onChange={onOptionsChange}\n      />\n\n      <PromSettings options={options} onOptionsChange={onOptionsChange} />\n    </>\n  );\n};\n","// https://github.com/facebook/react/issues/5465\n\nexport interface CancelablePromise<T> {\n  promise: Promise<T>;\n  cancel: () => void;\n}\n\nexport const makePromiseCancelable = <T>(promise: Promise<T>): CancelablePromise<T> => {\n  let hasCanceled_ = false;\n\n  const wrappedPromise = new Promise<T>((resolve, reject) => {\n    promise.then(val => (hasCanceled_ ? reject({ isCanceled: true }) : resolve(val)));\n    promise.catch(error => (hasCanceled_ ? reject({ isCanceled: true }) : reject(error)));\n  });\n\n  return {\n    promise: wrappedPromise,\n    cancel() {\n      hasCanceled_ = true;\n    },\n  };\n};\n"],"sourceRoot":""}